// Створити функцію яка приймає 1 параметр масив продуктів і повертає мутований масив
// Потрібно перебрати масив і якщо він має об'єкти в яких дублюються айді то квонтіті цих елементів потрібно сплюсувати
// а ті обє'кти в яких айді співпав видалити з масиву.
// (Потрібно мутувати масив, створювати новий не потрібно)

const products = [
  {
    id: 'sku1',
    qty: 1,
  },
  {
    id: 'sku2',
    qty: 2,
  },
  {
    id: 'sku3',
    qty: 3,
  },
  {
    id: 'sku1',
    qty: 6,
  },
  {
    id: 'sku1',
    qty: 8,
  },
  {
    id: 'sku1',
    qty: 6,
  },
  {
    id: 'sku1',
    qty: 6,
  },
  {
    id: 'sku1',
    qty: 6,
  },
  {
    id: 'sku2',
    qty: 19,
  },
  {
    id: 'sku4',
    qty: 1,
  },
  {
    id: 'sku1',
    qty: 8,
  },
];

// ті обєкти в яких дублюються айді - залишаємо, а всі інші видаляємо і лише доплюсовуємо квонтіті

function sortProduct(arr) {
  // на поточній ітерації перебираємо поточний товар
  for (let i = 0; i < arr.length; i++) {
    // console.log('поточний', arr[i]);
    // тепер поточний перебирає кожен наступний товар
    for (let j = i + 1; j < arr.length; j += 1) {
      // тепер умова якщо айді поточного продукту ітерації = айді наступного продукту в циклі, то ми поточне квонтіті + те що співпало і видаляємо j
      if (arr[i].id === arr[j].id) {
        arr[i].qty += arr[j].qty;
        arr.splice(j, 1);
        // після того як видалили продукт, вказуємо що треба відкотитись на ітерацію назад щоб далі ми перевірили ту ж саму позицію де замінився індекс(два продукти підряд з однаковим id)
        j -= 1;
      }
      //   console.log('наступний', arr[j]);
    }
  }
}
sortProduct(products);
console.log(products);
